"""
Database models and connection handling for UAT AutoCoder Plugin.

This module provides SQLAlchemy models for both:
1. features.db - AutoCoder feature tracking
2. uat_tests.db - UAT test management
"""

import os
import sqlite3
from pathlib import Path
from typing import Optional, List, Dict, Any
from contextlib import contextmanager
from datetime import datetime

try:
    from sqlalchemy import create_engine, Column, Integer, String, Boolean, DateTime, JSON, Text, ForeignKey, text
    from sqlalchemy.ext.declarative import declarative_base
    from sqlalchemy.orm import sessionmaker, Session, relationship
    from sqlalchemy.pool import StaticPool, QueuePool
    SQLALCHEMY_AVAILABLE = True
except ImportError:
    SQLALCHEMY_AVAILABLE = False
    print("Warning: SQLAlchemy not installed. Install with: uv pip install sqlalchemy")

# Base class for models
Base = declarative_base() if SQLALCHEMY_AVAILABLE else None


# ============================================================================
# features.db Models (AutoCoder Feature Database)
# ============================================================================

class Feature(Base if SQLALCHEMY_AVAILABLE else object):
    """
    Model representing a feature in the AutoCoder features.db database.

    This table tracks all features that need to be implemented for the project.
    """
    if SQLALCHEMY_AVAILABLE:
        __tablename__ = 'features'

        id = Column(Integer, primary_key=True)
        priority = Column(Integer, nullable=False, index=True)
        category = Column(String(100), nullable=False, index=True)
        name = Column(String(255), nullable=False)
        description = Column(Text, nullable=False)
        steps = Column(JSON, nullable=False)  # List of test steps
        passes = Column(Boolean, nullable=False, default=False, index=True)
        in_progress = Column(Boolean, nullable=False, default=False, index=True)
        dependencies = Column(JSON, nullable=False)  # List of feature IDs
        complexity_score = Column(Integer, nullable=True)
        created_at = Column(DateTime, default=datetime.utcnow)
        completed_at = Column(DateTime, nullable=True)

    def __repr__(self):
        return f"<Feature(id={self.id}, name='{self.name}', category='{self.category}', passes={self.passes})>"

    def to_dict(self) -> Dict[str, Any]:
        """Convert feature to dictionary."""
        return {
            'id': self.id,
            'priority': self.priority,
            'category': self.category,
            'name': self.name,
            'description': self.description,
            'steps': self.steps,
            'passes': self.passes,
            'in_progress': self.in_progress,
            'dependencies': self.dependencies,
            'complexity_score': self.complexity_score,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'completed_at': self.completed_at.isoformat() if self.completed_at else None
        }


# ============================================================================
# uat_tests.db Models (UAT Test Management)
# ============================================================================

class UATTestFeature(Base if SQLALCHEMY_AVAILABLE else object):
    """
    Model representing a UAT test scenario.

    These are generated by the Test Planner Agent based on completed features.
    """
    if SQLALCHEMY_AVAILABLE:
        __tablename__ = 'uat_test_features'

        id = Column(Integer, primary_key=True)
        priority = Column(Integer, nullable=False, index=True)
        phase = Column(String(50), nullable=False, index=True)  # smoke, functional, regression, uat
        journey = Column(String(100), nullable=False, index=True)  # authentication, payment, etc.
        scenario = Column(String(255), nullable=False)  # Human-readable test name
        description = Column(Text, nullable=False)  # What we're testing
        test_type = Column(String(50), nullable=False)  # e2e, visual, api, a11y
        test_file = Column(String(500), nullable=True)  # Path to Playwright test
        steps = Column(JSON, nullable=False)  # JSON array of test steps
        expected_result = Column(Text, nullable=False)
        status = Column(String(50), nullable=False, default='pending', index=True)  # pending, in_progress, passed, failed, skipped
        dependencies = Column(JSON, nullable=False)  # JSON array of test IDs
        result = Column(JSON, nullable=True)  # Screenshot, video, logs, error, duration
        devlayer_card_id = Column(String(100), nullable=True)  # Card created on failure
        started_at = Column(DateTime, nullable=True)
        completed_at = Column(DateTime, nullable=True)
        created_at = Column(DateTime, default=datetime.utcnow)
        status_history = Column(JSON, nullable=True)  # Track status changes: [{from, to, at, agent, reason}]

    def __repr__(self):
        return f"<UATTestFeature(id={self.id}, scenario='{self.scenario}', status='{self.status}')>"

    def to_dict(self) -> Dict[str, Any]:
        """Convert test feature to dictionary."""
        return {
            'id': self.id,
            'priority': self.priority,
            'phase': self.phase,
            'journey': self.journey,
            'scenario': self.scenario,
            'description': self.description,
            'test_type': self.test_type,
            'test_file': self.test_file,
            'steps': self.steps,
            'expected_result': self.expected_result,
            'status': self.status,
            'dependencies': self.dependencies,
            'result': self.result,
            'devlayer_card_id': self.devlayer_card_id,
            'started_at': self.started_at.isoformat() if self.started_at else None,
            'completed_at': self.completed_at.isoformat() if self.completed_at else None,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'status_history': self.status_history
        }


class UATTestPlan(Base if SQLALCHEMY_AVAILABLE else object):
    """
    Model representing a generated UAT test plan.

    Created by the Test Planner Agent after analyzing the PRD and completed features.
    """
    if SQLALCHEMY_AVAILABLE:
        __tablename__ = 'uat_test_plan'

        id = Column(Integer, primary_key=True)
        project_name = Column(String(255), nullable=False)
        cycle_id = Column(String(100), nullable=False, unique=True, index=True)
        total_features_completed = Column(Integer, nullable=False, default=0)
        journeys_identified = Column(JSON, nullable=False)  # JSON array of journey names
        recommended_phases = Column(JSON, nullable=False)  # JSON array of phase names
        test_prd = Column(Text, nullable=False)  # Generated test specification (Markdown)
        approved = Column(Boolean, nullable=False, default=False)
        created_at = Column(DateTime, default=datetime.utcnow)

    def __repr__(self):
        return f"<UATTestPlan(cycle_id='{self.cycle_id}', approved={self.approved})>"

    def to_dict(self) -> Dict[str, Any]:
        """Convert test plan to dictionary."""
        return {
            'id': self.id,
            'project_name': self.project_name,
            'cycle_id': self.cycle_id,
            'total_features_completed': self.total_features_completed,
            'journeys_identified': self.journeys_identified,
            'recommended_phases': self.recommended_phases,
            'test_prd': self.test_prd,
            'approved': self.approved,
            'created_at': self.created_at.isoformat() if self.created_at else None
        }


# ============================================================================
# Database Connection Management
# ============================================================================

class DatabaseManager:
    """
    Manages database connections for both features.db and uat_tests.db.

    Provides thread-safe connection pooling and session management.
    """

    def __init__(self, features_db_path: Optional[str] = None, uat_db_path: Optional[str] = None):
        """
        Initialize database manager.

        Args:
            features_db_path: Path to features.db (AutoCoder feature database)
            uat_db_path: Path to uat_tests.db (UAT test database)
        """
        self.features_db_path = features_db_path or self._find_features_db()
        self.uat_db_path = uat_db_path or os.path.expanduser('~/.autocoder/uat_tests.db')

        # Ensure directory exists for uat_tests.db
        uat_db_dir = os.path.dirname(self.uat_db_path)
        if uat_db_dir and not os.path.exists(uat_db_dir):
            os.makedirs(uat_db_dir, exist_ok=True)

        # SQLAlchemy engines (if available)
        self._features_engine = None
        self._uat_engine = None
        self._features_session_factory = None
        self._uat_session_factory = None

        if SQLALCHEMY_AVAILABLE:
            self._setup_sqlalchemy()

    def _find_features_db(self) -> str:
        """
        Find features.db in current directory or parent directories.

        Returns:
            Path to features.db
        """
        current_dir = Path.cwd()
        for parent in [current_dir] + list(current_dir.parents):
            features_db = parent / 'features.db'
            if features_db.exists():
                return str(features_db)
        # Default to current directory
        return str(current_dir / 'features.db')

    def _setup_sqlalchemy(self):
        """Setup SQLAlchemy engines and session factories with connection pooling."""
        # Features database engine
        if os.path.exists(self.features_db_path):
            features_db_url = f'sqlite:///{self.features_db_path}'
            self._features_engine = create_engine(
                features_db_url,
                connect_args={
                    'check_same_thread': False,
                    'timeout': 30  # 30-second timeout for connections
                },
                poolclass=QueuePool,
                pool_size=5,  # Base pool size for 3-5 concurrent agents
                max_overflow=10,  # Additional connections when pool is full
                pool_pre_ping=True,  # Verify connections before using
                pool_recycle=3600,  # Recycle connections after 1 hour
                echo=False
            )
            self._features_session_factory = sessionmaker(bind=self._features_engine)

        # UAT database engine with enhanced pooling for concurrent test agents
        uat_db_url = f'sqlite:///{self.uat_db_path}'
        self._uat_engine = create_engine(
            uat_db_url,
            connect_args={
                'check_same_thread': False,
                'timeout': 30  # 30-second timeout for connections
            },
            poolclass=QueuePool,
            pool_size=5,  # Base pool size for 3-5 concurrent agents
            max_overflow=10,  # Additional connections when pool is full
            pool_pre_ping=True,  # Verify connections before using
            pool_recycle=3600,  # Recycle connections after 1 hour
            echo=False
        )
        self._uat_session_factory = sessionmaker(bind=self._uat_engine)

        # Create tables if they don't exist
        Base.metadata.create_all(self._uat_engine)

    @contextmanager
    def features_session(self):
        """
        Get a session for the features database.

        Yields:
            SQLAlchemy Session for features.db
        """
        if not SQLALCHEMY_AVAILABLE or not self._features_session_factory:
            raise RuntimeError("SQLAlchemy not available or features.db not connected")
        session = self._features_session_factory()
        try:
            yield session
            session.commit()
        except Exception:
            session.rollback()
            raise
        finally:
            session.close()

    @contextmanager
    def uat_session(self):
        """
        Get a session for the UAT database.

        Yields:
            SQLAlchemy Session for uat_tests.db
        """
        if not SQLALCHEMY_AVAILABLE or not self._uat_session_factory:
            raise RuntimeError("SQLAlchemy not available")
        session = self._uat_session_factory()
        try:
            yield session
            session.commit()
        except Exception:
            session.rollback()
            raise
        finally:
            session.close()

    def query_passing_features(self) -> List[Dict[str, Any]]:
        """
        Query features.db for passing (completed) features.

        Returns:
            List of dictionaries representing passing features
        """
        if not SQLALCHEMY_AVAILABLE:
            # Fallback to raw SQLite
            return self._query_passing_features_raw()

        with self.features_session() as session:
            features = session.query(Feature).filter(Feature.passes == True).order_by(Feature.priority).all()
            return [feature.to_dict() for feature in features]

    def _query_passing_features_raw(self) -> List[Dict[str, Any]]:
        """
        Query passing features using raw SQLite (fallback).

        Returns:
            List of dictionaries representing passing features
        """
        if not os.path.exists(self.features_db_path):
            return []

        conn = sqlite3.connect(self.features_db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()

        try:
            cursor.execute("""
                SELECT id, priority, category, name, description, steps,
                       passes, in_progress, dependencies, complexity_score,
                       created_at, completed_at
                FROM features
                WHERE passes = 1
                ORDER BY priority
            """)
            rows = cursor.fetchall()
            return [dict(row) for row in rows]
        finally:
            conn.close()

    def get_pool_config(self) -> Dict[str, Any]:
        """
        Get connection pool configuration for UAT database.

        Returns:
            Dictionary with pool configuration details
        """
        if not SQLALCHEMY_AVAILABLE or not self._uat_engine:
            return {'error': 'SQLAlchemy not available'}

        pool = self._uat_engine.pool
        return {
            'pool_class': pool.__class__.__name__,
            'pool_size': pool.size() if hasattr(pool, 'size') else None,  # Call the method
            'max_overflow': getattr(pool, '_max_overflow', 10),  # Use private attribute
            'pool_pre_ping': getattr(pool, '_pre_ping', True),  # Assume True if configured
            'pool_recycle': getattr(pool, '_recycle', 3600),  # Default to 3600
            'timeout': pool.timeout()
        }

    def get_feature_stats(self) -> Dict[str, int]:
        """
        Get statistics from features.db.

        Returns:
            Dictionary with total, passing, in_progress, pending counts
        """
        if not SQLALCHEMY_AVAILABLE:
            return self._get_feature_stats_raw()

        with self.features_session() as session:
            total = session.query(Feature).count()
            passing = session.query(Feature).filter(Feature.passes == True).count()
            in_progress = session.query(Feature).filter(Feature.in_progress == True).count()
            # Pending = not passing AND not in_progress
            pending = total - passing - in_progress
            return {
                'total': total,
                'passing': passing,
                'in_progress': in_progress,
                'pending': pending
            }

    def _get_feature_stats_raw(self) -> Dict[str, int]:
        """Get feature statistics using raw SQLite (fallback)."""
        if not os.path.exists(self.features_db_path):
            return {'total': 0, 'passing': 0, 'in_progress': 0, 'pending': 0}

        conn = sqlite3.connect(self.features_db_path)
        cursor = conn.cursor()

        try:
            cursor.execute("SELECT COUNT(*) FROM features")
            total = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(*) FROM features WHERE passes = 1")
            passing = cursor.fetchone()[0]

            cursor.execute("SELECT COUNT(*) FROM features WHERE in_progress = 1")
            in_progress = cursor.fetchone()[0]

            # Pending = not passing AND not in_progress
            pending = total - passing - in_progress

            return {
                'total': total,
                'passing': passing,
                'in_progress': in_progress,
                'pending': pending
            }
        finally:
            conn.close()


# Singleton instance for easy access
_db_manager: Optional[DatabaseManager] = None


def get_db_manager() -> DatabaseManager:
    """
    Get the singleton database manager instance.

    Returns:
        DatabaseManager instance
    """
    global _db_manager
    if _db_manager is None:
        _db_manager = DatabaseManager()
    return _db_manager


# ============================================================================
# Convenience Functions
# ============================================================================

def get_passing_features() -> List[Dict[str, Any]]:
    """
    Get all passing (completed) features from features.db.

    Returns:
        List of passing feature dictionaries
    """
    db = get_db_manager()
    return db.query_passing_features()


def get_feature_statistics() -> Dict[str, int]:
    """
    Get feature statistics from features.db.

    Returns:
        Dictionary with total, passing, in_progress, pending counts
    """
    db = get_db_manager()
    return db.get_feature_stats()


# ============================================================================
# UAT Test Database Helper Functions
# ============================================================================

def get_test_by_id(test_id: int) -> Optional[Dict[str, Any]]:
    """
    Get a UAT test by its ID.

    Args:
        test_id: The test ID to retrieve

    Returns:
        Dictionary with test details, or None if not found
    """
    if not SQLALCHEMY_AVAILABLE:
        return _get_test_by_id_raw(test_id)

    db = get_db_manager()
    with db.uat_session() as session:
        test = session.query(UATTestFeature).filter(UATTestFeature.id == test_id).first()
        return test.to_dict() if test else None


def _get_test_by_id_raw(test_id: int) -> Optional[Dict[str, Any]]:
    """Get test by ID using raw SQLite (fallback)."""
    uat_db_path = os.path.expanduser('~/.autocoder/uat_tests.db')
    if not os.path.exists(uat_db_path):
        return None

    conn = sqlite3.connect(uat_db_path)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    try:
        cursor.execute("SELECT * FROM uat_test_features WHERE id = ?", (test_id,))
        row = cursor.fetchone()
        return dict(row) if row else None
    finally:
        conn.close()


def get_tests_by_status(status: str) -> List[Dict[str, Any]]:
    """
    Get UAT tests by status.

    Args:
        status: Status to filter by (pending, in_progress, passed, failed, skipped)

    Returns:
        List of test dictionaries with the specified status
    """
    if not SQLALCHEMY_AVAILABLE:
        return _get_tests_by_status_raw(status)

    db = get_db_manager()
    with db.uat_session() as session:
        tests = session.query(UATTestFeature).filter(
            UATTestFeature.status == status
        ).order_by(UATTestFeature.priority).all()
        return [test.to_dict() for test in tests]


def _get_tests_by_status_raw(status: str) -> List[Dict[str, Any]]:
    """Get tests by status using raw SQLite (fallback)."""
    uat_db_path = os.path.expanduser('~/.autocoder/uat_tests.db')
    if not os.path.exists(uat_db_path):
        return []

    conn = sqlite3.connect(uat_db_path)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    try:
        cursor.execute("""
            SELECT * FROM uat_test_features
            WHERE status = ?
            ORDER BY priority
        """, (status,))
        rows = cursor.fetchall()
        return [dict(row) for row in rows]
    finally:
        conn.close()


# Extend DatabaseManager with UAT-specific methods

def execute(self, query: str, params: tuple = None) -> None:
    """
    Execute a SQL query on the UAT database.

    Args:
        query: SQL query to execute
        params: Query parameters (optional)
    """
    if not SQLALCHEMY_AVAILABLE:
        self._execute_raw(query, params)
        return

    # Use raw SQLite for UAT database (simpler, more reliable)
    conn = sqlite3.connect(self.uat_db_path)
    cursor = conn.cursor()

    try:
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        conn.commit()
    finally:
        conn.close()


def _execute_raw(self, query: str, params: tuple = None) -> None:
    """Execute query using raw SQLite (fallback)."""
    conn = sqlite3.connect(self.uat_db_path)
    cursor = conn.cursor()

    try:
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        conn.commit()
    finally:
        conn.close()


def commit(self) -> None:
    """Commit pending transactions (no-op for SQLAlchemy, explicit for raw SQLite)."""
    # SQLAlchemy sessions auto-commit in context manager
    pass


def fetch_one(self, query: str, params: tuple = None) -> Optional[Dict[str, Any]]:
    """
    Fetch one row from UAT database.

    Args:
        query: SQL query
        params: Query parameters (optional)

    Returns:
        Dictionary with row data, or None if no results
    """
    if not SQLALCHEMY_AVAILABLE:
        return self._fetch_one_raw(query, params)

    with self.uat_session() as session:
        result = session.execute(text(query), params if params else ()).first()
        if result:
            # Convert RowProxy to dict
            return dict(result._mapping)
        return None


def update_and_fetch(self, query: str, params: tuple = None) -> Optional[Dict[str, Any]]:
    """
    Execute an UPDATE query with RETURNING clause and return the updated row.

    This is useful for atomic operations like claiming a test, where you want
    to update a row and return its new values in a single thread-safe operation.

    Args:
        query: SQL UPDATE query with RETURNING clause
        params: Query parameters (optional)

    Returns:
        Dictionary with updated row data, or None if no row matched

    Example:
        >>> result = db.update_and_fetch(
        ...     "UPDATE tests SET status = ? WHERE id = ? AND status = 'pending' RETURNING *",
        ...     ('in_progress', test_id)
        ... )
    """
    # Use raw SQLite for UPDATE with RETURNING (more reliable than SQLAlchemy)
    conn = sqlite3.connect(self.uat_db_path)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    try:
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)

        # Fetch the RETURNING result
        row = cursor.fetchone()
        conn.commit()

        return dict(row) if row else None
    except Exception:
        conn.rollback()
        raise
    finally:
        conn.close()


def _fetch_one_raw(self, query: str, params: tuple = None) -> Optional[Dict[str, Any]]:
    """Fetch one row using raw SQLite (fallback)."""
    conn = sqlite3.connect(self.uat_db_path)
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()

    try:
        if params:
            cursor.execute(query, params)
        else:
            cursor.execute(query)
        row = cursor.fetchone()
        return dict(row) if row else None
    finally:
        conn.close()


def update_status_with_history(
    session,
    test_id: int,
    new_status: str,
    agent_id: Optional[str] = None,
    reason: Optional[str] = None
) -> bool:
    """
    Update test status with history tracking.

    This function validates status transitions and records all changes
    in the status_history field for audit purposes.

    Args:
        session: SQLAlchemy session
        test_id: Test ID to update
        new_status: New status value
        agent_id: Optional agent making the change
        reason: Optional reason for status change

    Returns:
        True if update succeeded, False otherwise

    Raises:
        ValueError: If status transition is invalid
        SQLAlchemyError: If database operation fails

    Example:
        >>> with db.uat_session() as session:
        ...     update_status_with_history(
        ...         session, 42, 'in_progress',
        ...         agent_id='test_agent_1',
        ...         reason='Test claimed by agent'
        ...     )
        ...     session.commit()
    """
    # Import status_machine here to avoid circular imports
    from uat_plugin.status_machine import is_valid_transition

    # Get current test
    test = session.query(UATTestFeature).filter(
        UATTestFeature.id == test_id
    ).first()

    if not test:
        logger.error(f"Test #{test_id} not found")
        return False

    # Validate transition
    if not is_valid_transition(test.status, new_status):
        raise ValueError(
            f"Invalid status transition: {test.status} → {new_status}"
        )

    # Record history entry
    history_entry = {
        "from": test.status,
        "to": new_status,
        "at": datetime.utcnow().isoformat(),
        "agent": agent_id,
        "reason": reason
    }

    # Initialize history if needed
    if test.status_history is None:
        test.status_history = []

    # Add to history
    test.status_history.append(history_entry)

    # Update status
    old_status = test.status
    test.status = new_status

    # Update timestamps
    if new_status == "in_progress" and not test.started_at:
        test.started_at = datetime.utcnow()
    elif new_status in ["passed", "failed", "parked"]:
        test.completed_at = datetime.utcnow()

    logger.info(
        f"Test #{test_id} status: {old_status} → {new_status} "
        f"(agent={agent_id}, reason={reason})"
    )

    return True


# Monkey-patch the methods onto DatabaseManager
DatabaseManager.execute = execute
DatabaseManager._execute_raw = _execute_raw
DatabaseManager.commit = commit
DatabaseManager.fetch_one = fetch_one
DatabaseManager._fetch_one_raw = _fetch_one_raw
DatabaseManager.update_and_fetch = update_and_fetch


if __name__ == '__main__':
    # Test database connectivity
    print("Testing database connectivity...")
    db = get_db_manager()

    print(f"\nFeatures DB: {db.features_db_path}")
    print(f"UAT Tests DB: {db.uat_db_path}")

    stats = get_feature_statistics()
    print(f"\nFeature Statistics:")
    print(f"  Total: {stats['total']}")
    print(f"  Passing: {stats['passing']}")
    print(f"  In Progress: {stats['in_progress']}")
    print(f"  Pending: {stats['pending']}")

    passing = get_passing_features()
    print(f"\nPassing Features ({len(passing)}):")
    for feature in passing[:5]:  # Show first 5
        print(f"  - #{feature['id']}: {feature['name']} ({feature['category']})")
    if len(passing) > 5:
        print(f"  ... and {len(passing) - 5} more")
